% == Previous work ==
@article{Pacak,
  author = {Pacak, Andr\'{e} and Erdweg, Sebastian and Szab\'{o}, Tam\'{a}s},
  title = {A Systematic Approach to Deriving Incremental Type Checkers},
  year = {2020},
  issue_date = {November 2020},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {4},
  number = {OOPSLA},
  url = {https://doi.org/10.1145/3428195},
  doi = {10.1145/3428195},
  abstract = {Static typing can guide programmers if feedback is immediate. Therefore, all major IDEs incrementalize type checking in some way. However, prior approaches to incremental type checking are often specialized and hard to transfer to new type systems. In this paper, we propose a systematic approach for deriving incremental type checkers from textbook-style type system specifications. Our approach is based on compiling inference rules to Datalog, a carefully limited logic programming language for which incremental solvers exist. The key contribution of this paper is to discover an encoding of the infinite typing relation as a finite Datalog relation in a way that yields efficient incremental updates. We implemented the compiler as part of a type system DSL and show that it supports simple types, some local type inference, operator overloading, universal types, and iso-recursive types.},
  journal = {Proc. ACM Program. Lang.},
  month = {nov},
  articleno = {127},
  numpages = {28},
  keywords = {type system transformation, datalog, incremental type checking}
}

@article{Saioc_2022,
   title={A Tool for Describing and Checking Natural Semantics Definitions of Programming Languages},
   volume={369},
   ISSN={2075-2180},
   url={http://dx.doi.org/10.4204/EPTCS.369.4},
   DOI={10.4204/eptcs.369.4},
   journal={Electronic Proceedings in Theoretical Computer Science},
   publisher={Open Publishing Association},
   author={Saioc, Georgian-Vlad and Hüttel, Hans},
   year={2022},
   month=sep, pages={51–66} }

@InProceedings{Pettersson,
  author="Pettersson, Mikael",
  editor="Gyim{\'o}thy, Tibor",
  title="A compiler for natural semantics",
  booktitle="Compiler Construction",
  year="1996",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="177--191",
  abstract="Natural semantics is a formalism used for specifying both semantics and implementations of programming languages. Until recently, no practical implementation of the formalism existed. We have defined the Relational Meta-Language, RML, as an executable specification language for natural semantics. After a brief outline of the language, we describe the compilation strategy used by our rml2c compiler: transformations are applied to minimize non-determinism, and a continuationpassing style form is produced and simplified. Finally the CPS is emitted as low-level C code, using an efficient technique for implementing tailcalls. We also present performance measurements that support our choice of compilation strategy.",
  isbn="978-3-540-49939-8"
}

@article{TinkerType,
  title={{TinkerType}: a language for playing with formal systems},
  author={Michael Y. Levin and Benjamin C. Pierce},
  journal={Journal of Functional Programming},
  year={2003},
  volume={13},
  pages={295 - 316},
  url={https://api.semanticscholar.org/CorpusID:9655326}
}

# ==Background==
@Inbook{Hedin2011,
  author="Hedin, G{\"o}rel",
  editor="Fernandes, Jo{\~a}o M.
  and L{\"a}mmel, Ralf
  and Visser, Joost
  and Saraiva, Jo{\~a}o",
  title="An Introductory Tutorial on JastAdd Attribute Grammars",
  bookTitle="Generative and Transformational Techniques in Software Engineering III: International Summer School, GTTSE 2009, Braga, Portugal, July 6-11, 2009. Revised Papers",
  year="2011",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="166--200",
  abstract="JastAdd is an open-source system for generating compilers and other language-based tools. Its declarative specification language is based on reference attribute grammars and object-orientation. This allows tools to be implemented as composable extensible modules, as exemplified by JastAddJ, a complete extensible Java compiler. This tutorial gives an introduction to JastAdd and its core attribute grammar mechanisms, and how to use them when solving key problems in building language-based tools. A simple state machine language is used as a running example, showing the essence of name analysis, adding graphs to the abstract syntax tree, and computing circular properties like reachability. Exercises are included, and code for the examples is available online.",
  isbn="978-3-642-18023-1",
  doi="10.1007/978-3-642-18023-1_4",
  url="https://doi.org/10.1007/978-3-642-18023-1_4"
}

@article{JastAdd,
author = {Hedin, Görel and Magnusson, Eva},
year = {2001},
month = {06},
pages = {59-78},
title = {JastAdd - A Java-based system for implementing front ends},
volume = {44},
journal = {Electronic Notes in Theoretical Computer Science},
doi = {10.1016/S1571-0661(04)80920-4}
}

@article{jastaddref,
	author = {},
  url={https://jastadd.cs.lth.se/web/documentation/reference-manual.php},
	title = {JastAdd Reference Manual},
	howpublished = {\url{https://jastadd.cs.lth.se/web/documentation/reference-manual.php}},
	year = {},
	note = {[Accessed 06-12-2023]},
}

@article{RAG,
  title = "Reference Attributed Grammars",
  abstract = "An object-oriented extension to canonical attribute grammars is described, permitting attributes to be references to arbitrary nodes in the syntax tree, and attributes to be accessed via the reference attributes. Important practical problems such as name and type analysis for object-oriented languages can be expressed in a concise and modular manner in these grammars, and an optimal evaluation algorithm is available. An extensive example is given, capturing all the key constructs in object-oriented languages including block structure, classes, inheritance, qualified use, and assignment compatibility in the presence of subtyping. The formalism and algorithm have been implemented in APPLAB, an interactive language development tool.",
  author = "G{\"o}rel Hedin",
  year = "2000",
  language = "English",
  volume = "24",
  pages = "301--317",
  journal = "Informatica",
  issn = "0868-4952",
  publisher = "Slovenian Society Informatika",
  number = "3",
}

@book{Pierce,
  author = {Pierce, Benjamin C.},
  title = {Types and Programming Languages},
  year = {2002},
  isbn = {0262162091},
  publisher = {The MIT Press},
  edition = {1st},
  abstract = {A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems -- and of programming languages from a type-theoretic perspective -- has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.}
}

@article{AGs,
  title={Semantics of context-free languages},
  author={Donald Ervin Knuth},
  journal={Mathematical systems theory},
  year={1968},
  volume={2},
  pages={127-145},
  url={https://api.semanticscholar.org/CorpusID:5182310}
}

@misc{beaver,
	author = {},
  url={https://beaver.sourceforge.net/},
	title = {{B}eaver - a {L}{A}{L}{R} {P}arser {G}enerator},
	howpublished = {\url{https://beaver.sourceforge.net/}},
	year = {},
	note = {[Accessed 28-11-2023]},
}

@misc{jflex,
	author = {},
  url={https://jflex.de/},
	title = {{J}{F}lex - The fast scanner generator for {J}ava},
	year = {},
	note = {[Accessed 28-11-2023]},
}

# ==Introduction==
@inproceedings{10.1145/1985793.1985889,
author = {Dietl, Werner and Dietzel, Stephanie and Ernst, Michael D. and Mu\c{s}lu, Kivan\c{c} and Schiller, Todd W.},
title = {Building and Using Pluggable Type-Checkers},
year = {2011},
isbn = {9781450304450},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1985793.1985889},
doi = {10.1145/1985793.1985889},
abstract = {This paper describes practical experience building and using pluggable type-checkers. A pluggable type-checker refines (strengthens) the built-in type system of a programming language. This permits programmers to detect and prevent, at compile time, defects that would otherwise have been manifested as run-time errors. The prevented defects may be generally applicable to all programs, such as null pointer dereferences. Or, an application-specific pluggable type system may be designed for a single application.We built a series of pluggable type checkers using the Checker Framework, and evaluated them on 2 million lines of code, finding hundreds of bugs in the process. We also observed 28 first-year computer science students use a checker to eliminate null pointer errors in their course projects.Along with describing the checkers and characterizing the bugs we found, we report the insights we had throughout the process. Overall, we found that the type checkers were easy to write, easy for novices to productively use, and effective in finding real bugs and verifying program properties, even for widely tested and used open source projects.},
booktitle = {Proceedings of the 33rd International Conference on Software Engineering},
pages = {681–690},
numpages = {10},
keywords = {java, bug finding, type system, type qualifier, enum, pluggable type, binary name, field descriptor, case study, intern, fully qualified name, nonnull, annotation, enumeration},
location = {Waikiki, Honolulu, HI, USA},
series = {ICSE '11}
}

@inproceedings{10.5555/1251375.1251384,
author = {Johnson, Rob and Wagner, David},
title = {Finding User/Kernel Pointer Bugs with Type Inference},
year = {2004},
publisher = {USENIX Association},
address = {USA},
abstract = {Today's operating systems struggle with vulnerabilities from careless handling of user space pointers. User/kernel pointer bugs have serious consequences for security: a malicious user could exploit a user/kernel pointer bug to gain elevated privileges, read sensitive data, or crash the system. We show how to detect user/kernel pointer bugs using type-qualifier inference, and we apply this method to the Linux kernel using CQUAL, a type-qualifier inference tool. We extend the basic type-inference capabilities of CQUAL to support context-sensitivity and greater precision when analyzing structures so that CQUAL requires fewer annotations and generates fewer false positives. With these enhancements, we were able to use CQUAL to find 17 exploitable user/kernel pointer bugs in the Linux kernel. Several of the bugs we found were missed by careful hand audits, other program analysis tools, or both.},
booktitle = {Proceedings of the 13th Conference on USENIX Security Symposium - Volume 13},
pages = {9},
numpages = {1},
location = {San Diego, CA},
series = {SSYM'04}
}

@INPROCEEDINGS{10190394,
  author={Rizwan, Momina and Caldas, Ricardo and Reichenbach, Christoph and Mayr, Matthias},
  booktitle={2023 IEEE/ACM 5th International Workshop on Robotics Software Engineering (RoSE)},
  title={EzSkiROS: A Case Study on Embedded Robotics DSLs to Catch Bugs Early},
  year={2023},
  volume={},
  number={},
  pages={61-68},
  doi={10.1109/RoSE59155.2023.00014}
}

@article{higherorderattributegrammars,
author = {Vogt, H. H. and Swierstra, S. D. and Kuiper, M. F.},
title = {Higher Order Attribute Grammars},
year = {1989},
issue_date = {July 1989},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {24},
number = {7},
issn = {0362-1340},
url = {https://doi.org/10.1145/74818.74830},
doi = {10.1145/74818.74830},
abstract = {A new kind of attribute grammars, called higher order attribute grammars, is defined. In higher order attribute grammars the structure tree can be expanded as a result of attribute computation. A structure tree may be stored in an attribute. The term higher order is used because of the analogy with higher order functions, where a function can be the result or parameter of another function. A relatively simple method, using OAGs, is described to derive an evaluation order on the defining attribute occurrences which comprises all possible direct and indirect attribute dependencies. As in OAGs, visit-sequences are computed from which an efficient algorithm for attribute evaluation can be derived.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {131–145},
numpages = {15}
}


@inproceedings{10.1145/73141.74830,
author = {Vogt, H. H. and Swierstra, S. D. and Kuiper, M. F.},
title = {Higher Order Attribute Grammars},
year = {1989},
isbn = {089791306X},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/73141.74830},
doi = {10.1145/73141.74830},
abstract = {A new kind of attribute grammars, called higher order attribute grammars, is defined. In higher order attribute grammars the structure tree can be expanded as a result of attribute computation. A structure tree may be stored in an attribute. The term higher order is used because of the analogy with higher order functions, where a function can be the result or parameter of another function. A relatively simple method, using OAGs, is described to derive an evaluation order on the defining attribute occurrences which comprises all possible direct and indirect attribute dependencies. As in OAGs, visit-sequences are computed from which an efficient algorithm for attribute evaluation can be derived.},
booktitle = {Proceedings of the ACM SIGPLAN 1989 Conference on Programming Language Design and Implementation},
pages = {131–145},
numpages = {15},
location = {Portland, Oregon, USA},
series = {PLDI '89}
}

