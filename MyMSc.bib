% == Previous work ==
@article{Pacak,
  author = {Pacak, Andr\'{e} and Erdweg, Sebastian and Szab\'{o}, Tam\'{a}s},
  title = {A Systematic Approach to Deriving Incremental Type Checkers},
  year = {2020},
  issue_date = {November 2020},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {4},
  number = {OOPSLA},
  url = {https://doi.org/10.1145/3428195},
  doi = {10.1145/3428195},
  abstract = {Static typing can guide programmers if feedback is immediate. Therefore, all major IDEs incrementalize type checking in some way. However, prior approaches to incremental type checking are often specialized and hard to transfer to new type systems. In this paper, we propose a systematic approach for deriving incremental type checkers from textbook-style type system specifications. Our approach is based on compiling inference rules to Datalog, a carefully limited logic programming language for which incremental solvers exist. The key contribution of this paper is to discover an encoding of the infinite typing relation as a finite Datalog relation in a way that yields efficient incremental updates. We implemented the compiler as part of a type system DSL and show that it supports simple types, some local type inference, operator overloading, universal types, and iso-recursive types.},
  journal = {Proc. ACM Program. Lang.},
  month = {nov},
  articleno = {127},
  numpages = {28},
  keywords = {type system transformation, datalog, incremental type checking}
}

@InProceedings{10.1007/3-540-61053-7_61,
  author="Pettersson, Mikael",
  editor="Gyim{\'o}thy, Tibor",
  title="A compiler for natural semantics",
  booktitle="Compiler Construction",
  year="1996",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="177--191",
  abstract="Natural semantics is a formalism used for specifying both semantics and implementations of programming languages. Until recently, no practical implementation of the formalism existed. We have defined the Relational Meta-Language, RML, as an executable specification language for natural semantics. After a brief outline of the language, we describe the compilation strategy used by our rml2c compiler: transformations are applied to minimize non-determinism, and a continuationpassing style form is produced and simplified. Finally the CPS is emitted as low-level C code, using an efficient technique for implementing tailcalls. We also present performance measurements that support our choice of compilation strategy.",
  isbn="978-3-540-49939-8"
}

# ==Background==
@Inbook{Hedin2011,
  author="Hedin, G{\"o}rel",
  editor="Fernandes, Jo{\~a}o M.
  and L{\"a}mmel, Ralf
  and Visser, Joost
  and Saraiva, Jo{\~a}o",
  title="An Introductory Tutorial on JastAdd Attribute Grammars",
  bookTitle="Generative and Transformational Techniques in Software Engineering III: International Summer School, GTTSE 2009, Braga, Portugal, July 6-11, 2009. Revised Papers",
  year="2011",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="166--200",
  abstract="JastAdd is an open-source system for generating compilers and other language-based tools. Its declarative specification language is based on reference attribute grammars and object-orientation. This allows tools to be implemented as composable extensible modules, as exemplified by JastAddJ, a complete extensible Java compiler. This tutorial gives an introduction to JastAdd and its core attribute grammar mechanisms, and how to use them when solving key problems in building language-based tools. A simple state machine language is used as a running example, showing the essence of name analysis, adding graphs to the abstract syntax tree, and computing circular properties like reachability. Exercises are included, and code for the examples is available online.",
  isbn="978-3-642-18023-1",
  doi="10.1007/978-3-642-18023-1_4",
  url="https://doi.org/10.1007/978-3-642-18023-1_4"
}

@article{RAG,
  title = "Reference Attributed Grammars",
  abstract = "An object-oriented extension to canonical attribute grammars is described, permitting attributes to be references to arbitrary nodes in the syntax tree, and attributes to be accessed via the reference attributes. Important practical problems such as name and type analysis for object-oriented languages can be expressed in a concise and modular manner in these grammars, and an optimal evaluation algorithm is available. An extensive example is given, capturing all the key constructs in object-oriented languages including block structure, classes, inheritance, qualified use, and assignment compatibility in the presence of subtyping. The formalism and algorithm have been implemented in APPLAB, an interactive language development tool.",
  author = "G{\"o}rel Hedin",
  year = "2000",
  language = "English",
  volume = "24",
  pages = "301--317",
  journal = "Informatica",
  issn = "0868-4952",
  publisher = "Slovenian Society Informatika",
  number = "3",
}

@book{Pierce,
  author = {Pierce, Benjamin C.},
  title = {Types and Programming Languages},
  year = {2002},
  isbn = {0262162091},
  publisher = {The MIT Press},
  edition = {1st},
  abstract = {A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems -- and of programming languages from a type-theoretic perspective -- has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.}
}

@misc{beaver,
	author = {},
  url={https://beaver.sourceforge.net/},
	title = {{B}eaver - a {L}{A}{L}{R} {P}arser {G}enerator},
	howpublished = {\url{https://beaver.sourceforge.net/}},
	year = {},
	note = {[Accessed 28-11-2023]},
}
