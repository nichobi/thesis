\documentclass[nofilelist]{cslthse-msc}
% to show a list of used packages at the end of the document, delete the nofilelist option
%\documentclass{cslthse-msc}
\usepackage[utf8]{inputenc}
\usepackage[main=british,swedish]{babel}
\usepackage{amsmath}
%\usepackage{amsfonts}
%%\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{makeidx}
\usepackage{graphicx}
\usepackage[titletoc, header, page]{appendix}
\usepackage{transparent}
\usepackage{tikz}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{svg}
\usepackage{subcaption}
\usetikzlibrary{fit,positioning,shapes.geometric}

\lstdefinestyle{mystyle}{
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2
}
\lstset{style=mystyle}
\lstdefinelanguage{jrag}[]{java}{
  morekeywords={aspect, syn, eq, inh}
}

\setcounter{secnumdepth}{4} % Number subsubsections
%\setcounter{tocdepth}{4} % Include subsubsections in table of contents

% used to display the used files at the end. Select nofilelist as a package option to disable this
\listfiles % initialize

%\geometry{showframe}
%better like this?
\student{Nicholas Boyd Isacsson}{nicholas@isacsson.se}
%\students{Flavius Gruian}{Flavius.Gruian@cs.lth.se}{Camilla Lekebjer}{Camilla.Lekebjer@cs.lth.se}

\thesisnumber{LU-CS-EX: 2023-79} % Magic Number! Do not change unless Birger Swahn asks you to do so!
% default is Master. Uncomment the following for "kandidatarbete"/Bachelor's thesis
%\thesistype{Bachelor}{Kandidatarbete}

%\title{Formatting a Master's Thesis}
\title{Type Checker Generation using Reference Attribute Grammars}
\begin{otherlanguage}{swedish}
\svensktitel{Infoga den Svenska titeln här!}
\end{otherlanguage}

%\onelinetitle
%\twolinestitle
\threelinestitle
%\fourlinestitle

%\subtitle{A {\LaTeX} class}
%\company{The Corporation AB LTD Inc}
%\supervisors{John Deer, \href{mailto:jdeer@company.com}{\texttt{jdeer@company.com}}}{Don Jeer, \href{mailto:djeer@xy.lth.se}{\texttt{djeer@xy.lth.se}}}
\supervisor{Christoph Reichenbach, \href{mailto:christoph.reichenbach@cs.lth.se}{\texttt{christoph.reichenbach@cs.lth.se}}}
%\supervisor{John Deer, \href{mailto:jdeer@company.com}{\texttt{jdeer@company.com}}}
\examiner{Niklas Fors, \href{mailto:niklas.fors@cs.lth.se}{\texttt{niklas.fors@cs.lth.se}}}

\date{\today}
%\date{January 16, 2015}

% For questions to people reviewing, remove before finalizing
\newcommand{\reviewquestion}[1]{\textcolor{red}{\begin{itemize}\item Question: #1\end{itemize}}}
%\newcommand{\reviewquestion}[1]{}

\acknowledgements{
Sincere thanks to Christoph Reichenbach,
whose enthusiasm for the subject inspired me to pursue this subject
and whose guidance in matters of both implementation and writing were key to this thesis.
Additional thanks to Niklas Fors for providing several valuable insights, greatly simplifying certain components and Alexandru Dura for providing some guidance to JastAdd internals.

I would also like to thank my partner Lo-Isabel Krantz Andrée, my family, and Moritz for their support throughout the duration of this project.

%If you want to thank people, do it here, on a separate right-hand page. Both the U.S. \textit{acknowledgments} and the British \textit{acknowledgements} spellings are acceptable.
%
%We would like to thank Lennart Andersson for his feedback on this template.
%
%We would also like thank Camilla Lekebjer for her contribution on this template, as well as Magnus Hultin for his popular science summary class and example document.
%
%Thanks also go to the following (former) students for helping with feedback and suggestions on this template: Mikael Persson, Christoffer Lundgren, Mahmoud Nasser.
}

\theabstract{
%Your abstract should capture, in English, the whole thesis with focus on the problem and solution in 150 words. It should be placed on a separate right-hand page, with an additional \textit{1cm} margin on both left and right. Avoid acronyms, footnotes, and references in the abstract if possible.
%Leave a \textit{2cm} vertical space after the abstract and provide a few keywords relevant for your report. Use five to six words, of which at most two should be from the title.
}

%\keywords{MSc, BSc, template, report, style, structure}
\keywords{type checking, type theory, code generation, reference attribute grammars}

%% Only used to display font sizes
\makeatletter
\newcommand\thefontsize[1]{{#1 \f@size pt\par}}
\makeatother
%%%%%%%%%%

\begin{document}
\renewcommand{\bibname}{References}

\makefrontmatter
\chapter{Introduction} % should give the background of your work. Important parts to cover:
% Give the context of your work, have a short introduction to the area.
While writing software, developers often make mistakes.
Catching these mistakes as early as possible can prevent these bugs from ever reaching production code.
Type checkers are one of the most common static checking methods, ensuring that the correct data types are used, but creating a new type checker is often an arduous process, requiring large amounts of complex code.
Furthermore, making changes to the typing rules of a language can require extensive rewrites in many different parts of the type checker's codebase.

% Define the problem you are solving (or trying to solve).
In this thesis we examine the feasibility of automating the writing of type checkers, based on the formal definition of the language's typing rules, using JastAdd's implementation of reference attribute grammars.

%TODO: Give an overview of the other sections
The rest of this paper is outlined as follows.
% This chapter introduces the
Chapter 2 presents the necessary background information for the report.
Chapter 3 describes the design and implementation of our program, followed by demonstrations of its results in chapter 4.
Chapter 5 discusses the results in a more general sense, before the conclusion in chapter 6.

% Specify your contributions. What does this particular work/report bring to the research are or to the body of knowledge?
\section{Research questions}
To formulate our goals more concretely, we've set out to answer the following research questions:
\newcommand{\rqone}{What kinds of typing rules can we translate through RAG?}
\newcommand{\rqtwo}{How can we implement the translations and into what form?}
\newcommand{\rqthree}{What are the potential issues of translating typing rules into JastAdd-based RAGs?}
\begin{itemize}
  \item \rqone
  \item \rqtwo
  \item \rqthree
\end{itemize}

\section{Related work} % Maybe move to discussion?
% Describe related work (literature study). Besides listing other work in the area, mention how is it related or relevant to your work. The tradition in some research area is to place this part at the end of the report (check with your supervisor).
Pacak et al. implemented a compiler for generating incremental type checkers using Datalog\cite{Pacak}.
While the goal is similar to ours, they take a different approach, by converting typing rules into the declarative logic programming language.

Their work is thereby largely focused on expressing typing rules within the limits of the Datalog language, which can only compute finite relations.
We have a significantly different compilation target, JastAdd, which allows us to use reference attribute grammars to evaluate the typing relations, which we write in a more iterative approach.

Additionally, their project defines a formalism for expressing typing rules within the Datalog language, ours defines a language which aims to keep as close as possible to the traditional inference rules used for typing rules, to minimise the difficulty of translation.

\reviewquestion{Circular attributes?}


\chapter{Background}
%\section{Theory} % should contain the theoretical background needed to understand your work, if necessary.
This chapter aims to provide all the background information required to understand the work presented in the rest of the report.
The first section explains abstract syntax trees, which are extensively utilised in almost every stage of our project, both in terms of our implementation and the input to the program.
The next section details type systems, by first introducing data types, then explaining the components required for a type system, followed by a description of static type checkers.

\section{Abstract syntax trees}
An abstract syntax tree (AST) is a tree-based representation of the syntax of a program.
Each node in the tree represents a syntactic construct of the language, such as expressions, statements or declarations and the branches represent the structure.
It's abstract in that it neglects to include all the concrete details of the syntax, but rather focuses on the structure of the program.
Structural elements of the source code, such as parenthesis, commas and brackets, are no longer necessary, as the structure of the tree conveys this information.
A statement like \verb|if (true) then {1} else {0}| maybe instead be represented by an if-else node, with named branches pointing towards the condition and the two values.

This layer of abstraction makes it easier to write analyses for the program, as we can focus on the key elements and structure.

\section{Type theory}
In this section we'll discuss the elements of type theory required to understand this thesis.
Firstly, we'll discuss what types are and give some examples of their use.
Next, we'll describe type system, which form a relation between types and expressions.

\subsection{Data types}
Computer software generally needs to handle and manipulate several different types of data in one program, such as numbers or text.
Most programming languages come with a number of built-in data types, from different kinds of numbers (integers, floating point) to strings or lists and arrays.

Different parts of programs may have different constraints on the types of expressions, such as a print function requiring a string of text, or a plus function requiring some kind of number.

\subsection{Type checking}
There are two main approaches to ensuring that the aforementioned constraints are upheld, dynamic and static type-checking.
Dynamic checking is done performed runtime, with each type checked only when needed.
Static checking is performed on the code before it's run, usually as part of compilation, preventing many faulty programs from being run at all.

As our project generates a static type checker, we will focus our explanations on that topic.
Static checkers analyse the structure of the source code, often in the form of an abstract syntax tree.
Conservative

\subsection{Type systems}
A type system consists of two parts, a type syntax, describing the available types of a language; and typing rules, denoting how types should be assigned to expressions within the language.
\subsubsection{Type syntax}
A type syntax is a definition of the valid types within a language.
It can consist of fundamental types, such as integers or booleans.
There may also be parameterised or composite types, for example lists may have a type parameter defining what values it can contain.

\subsubsection{Typing rules}
The typing relation, notated \lstinline{t : T}, is a link between the expressions of a language and the types of the type syntax.
The left-hand side is an expression in the object lanuage, typically written in its native syntax, the right-hand side a type from the aforementioned type syntax.

Typing rules are a manner of inference rules, which in their simplest form, consist of no more than a typing relation.
The typing rule \lstinline{T-True} seen in figure \ref{typingruleexampletrue}, for example, simply assigns the type of \lstinline{Bool} to the expression \lstinline{true}.
Additionally, the typing rules in these examples have a name, given in parentheses next to the rule, though this is merely for reference.

\begin{figure}[h]
  \begin{equation}
    \tag{T-True}
    \text{true} : \text{Bool}
  \end{equation}
  \caption{Typing rule for a true expression}
  \label{typingruleexampletrue}
\end{figure}

Typing rules may also have premises, a number of conditions which must hold for the typing rule to apply.
The notational convention here is to put the premises above a bar, with the conclusion underneath it.

\begin{figure}[h]
  \begin{equation}
    \tag{T-If}
    \frac{
      t_1 : \text{Bool}\quad
      t_2 : \text{T}\quad
      t_3 : \text{T}
    }{
      \text{if } t_1 \text{ then } t_2 \text{ else } t_3 : \text{T}
    }
  \end{equation}
  \caption{Typing rule for an if-expression}
  \label{typingruleexampleif}
\end{figure}

Figure \ref{typingruleexampleif} shows an example rule, typing an if-expression.
The bottom line, the conclusion, contains the keywords of the if-expression and three variables $t_i$ which represent any term within the language.
Above the bar are three premises, placing constraints on the three variables, which must hold for the typing rule to apply.
The first constrains $t_1$ to the type bool, the second two constrain $t_2$ and $t_3$ to a type variable T, which represents any single arbitrary type within the type syntax.
While T may be any type, it must consistently be the same type within any single evaluation of the rule, i.e. the two terms must have the same type.
This T also appears in the conclusion, as the resulting type of the if-expression, meaning the result of the entire expression will be that of the $t_2$ and $t_3$ terms.

\section{Reference Attribute Grammars}
This section introduces the subject of Reference Attribute Grammars (RAGs), first explaining the theory behind them, then introducing JastAdd, an implementation of RAGs within a Java meta-compiliation system\cite{jastadd}.

\subsection{Reference Attribute Grammars}
Reference Attribute Grammars (RAGs) are an extension to Attribute Grammars (AGs), a formalism used for specifying the semantics of programming languages.
AGs provide a systematic way to define computations on the nodes of an abstract syntax tree, associating attributes with language constructs and are commonly used in the context of compiler construction, where they help define the translation of source code into executable code\cite{AGs}.

RAGs extend these properties by introducing a new kind of attribute, allowing references to other nodes in the AST, and through the references accessing the attributes of other nodes.
This provides a simplified and more flexible method for interconnectedness between nodes\cite{RAG}.

\subsection{JastAdd}
JastAdd is an implementation of RAGs for Java, offering a flexible system for writing language analysis in an object-oriented fashion.
\cite{JastAdd}
\subsubsection{AST specification}\label{astdef}
One of the key components of a JastAdd projects are the \verb|.ast| files, which declare the structure of the abstract syntax tree.
This specification is then used by JastAdd to generate Java classes representing the nodes of the AST.
These AST classes can have a variety of forms, supporting both abstract classes and subclasses, and can contain components such as Java types, tokens and child nodes, and these components may also be optional or list components.
For a detailed overview of the syntax, see the reference manual\cite{jastaddref}.

\subsubsection{RAG Modules}
\begin{figure}[h]
\begin{lstlisting}[language=jrag]
aspect TypingRules {
  syn Type Zero.type() {
    return new Int();
  }
}
\end{lstlisting}
  \caption{Snippet of a .jrag file, declaring a type attribute for the Zero AST node}
  \label{boolstrgen}
\end{figure}
The RAG modules written in \verb|.jrag| files, declare the attributes to be included in the classes generated by the AST specification.
The files use a syntax very similar to that of Java to declare attributes of a variety of different kinds, and the body of methods corresponds directly to Java code.

\chapter{Approach/Design} % should contain a description of your solution(s), with all the theoretical background needed. On occasion this is replaced by a subset or all of the following:

\section{Architecture}
In this section we'll be providing an overview of our architecture.
Since it contains many different components, it may be helpful to refer to the overview graph in figure \ref{overviewgraph} while reading.
It represents the flow of the program, with components and artefacts (represented as rectangular boxes) with arrows linking them to actions (elliptical boxes) which in turn have arrows to the new components and artefacts they produce.
The dashed arrows from represent links from the template components that exist in the current experimental state of the project, but in a finished product would instead link to component from the object language's own compilation environment.
%It uses rectangular boxes to represent the concrete data or artefacts of the procedure, and elliptical boxes to represent the actions performed with them.
\begin{figure}[]
  \resizebox{\textwidth}{!}{%
  \begin{tikzpicture}[
      every node/.style = {draw=black, rounded corners, align=center},
      every path/.style = {draw, -latex}
    ]
    \node (typerules)                               {Typing rules\\definition (\ref{typingruledefinition})};
    \node (trparsing) [right=of typerules, ellipse] {Scan,\\parse,\\build};
    \node (trparser)  [above=of trparsing]          {Typing rule parser\\(\ref{typingrulesparser})};
    \node (trast)     [right=of trparsing]          {Typing rules AST\\(\ref{typingrulesast})};

    %\node (typecheckgen) [below=of trast, ellipse, text width=5cm] {
    %  \textbf{Type checker generation}\\
    %  \hrule
    %  \begin{itemize}[noitemsep,topsep=2pt]
    %    \item Copy template
    %    \item Generate type checker from typing rules
    %  \end{itemize}
    %};
    \node (typecheckgen)       [below=of trast, ellipse] {Generate\\type checker};
    \node (typingrulecompiler) [right=of trast]          {Typing rule\\compiler (\ref{typingrulecompiler})};
    \node (typechecker)        [below=of typecheckgen]   {Type checker};

    \node (olast)     [below=of typerules] {AST specification\\(\ref{astdef})};

    \node (outputtypechecking) [below=of typechecker, ellipse] {Perform\\typechecking};
    \node (inputast)           [left=of outputtypechecking]    {Input program\\AST};
    \node (outputparsing)      [left=of inputast, ellipse]     {Scan,\\parse,\\build};
    \node (typeerrors)         [right=of outputtypechecking]   {Type errors\\(\ref{errorhandling})};
    \node (inputprog)          [left=of outputparsing]         {Input program};

    %\node (template) [below=of inputast, text width=6cm] {
    %  \textbf{Type checker template}\\
    %  \hrule
    %  \begin{itemize}[noitemsep,topsep=2pt]
    %    \item Scanner, parser, builder
    %    \item Project files
    %    \item Type checking algorithm (\ref{typecheckingalgorithm})
    %  \end{itemize}
    %};
    \node (templateparser)        [below=of outputparsing]                               {Tree-based\\parser\\(\ref{treebasedparser})};
    \node (templateprojectfiles)  at (inputast |- templateparser)                        {Project files\\(\ref{projectfiles})};
    \node (typecheckingalgorithm) at (outputtypechecking |- templateparser)              {Type checking\\aspect (\ref{typecheckingaspect})};
    \node (templatetypesyntax)    [right=of typecheckingalgorithm]                       {Type syntax\\AST};
    \node (template)              [dashed, fit=(templateparser) (typecheckingalgorithm) (templatetypesyntax)] {};
    \node                         [above, draw=none] at (template.north)                 {Template};

    \node (userinput)   [dashed, fill=none, fit=(typerules) (olast)]                  {};
    \node               [above, draw=none] at (userinput.north)                       {Object language\\static semantics};
    %\node (typechecker) [dashed, fill=none, fit=(outputparsing) (outputtypechecking)] {};
    %\node               [above, draw=none] at (typechecker.north)                     {Type checker};

    \draw (typerules)          to (trparsing);
    \draw (trparser)           to (trparsing);
    \draw (trparsing)          to (trast);
    \draw (trast)              to (typecheckgen);
    \draw (typingrulecompiler) to (typecheckgen);
    \draw (typechecker)        to (outputtypechecking);
    \draw (olast)              to (outputparsing);
    \draw (outputparsing)      to (inputast);
    \draw (inputast)           to (outputtypechecking);
    \draw (outputtypechecking) to (typeerrors);
    \draw (typecheckgen)       to (typechecker);
    \draw (inputprog)          to (outputparsing);

    \draw[dashed] (templateparser)                  to (outputparsing);
    \draw         (typecheckingalgorithm)           to (outputtypechecking);
    \draw[dashed] (templateprojectfiles.north west) to (outputparsing);
    \draw[dashed] (templateprojectfiles.north east) to (outputtypechecking);
    \draw[dashed] (templatetypesyntax)              to (outputtypechecking);

  \end{tikzpicture}
  }
  \caption{An overview of the project components and flow.}
  \label{overviewgraph}
\end{figure}

\subsection{Typing rule definition}\label{typingruledefinition}
To express typing rules, we created a simple ASCII representation of the natural deduction notation used by Pierce\cite{Pierce}.
Custom DSL
Include typing rules AST specification (or BNF?)
ASCII representation of natural deduction %BNF (is it BNF?)
\subsubsection{Language}\label{sectionlanguage}

\begin{figure}[h]
\centering
\begin{minipage}{.45\textwidth}
  \centering
  \begin{equation}
    \tag{T-True}
    \text{true} : \text{Bool}
  \end{equation}
  %\caption*{Pierce syntax}
  %\label{fig:sub1}
\end{minipage}%
\hspace{.1\textwidth}\begin{minipage}{.45\textwidth}
  \centering
\begin{lstlisting}[]
[T-True]
True : Bool
\end{lstlisting}
  %\caption*{ASCII representation}
  %\label{fig:sub2}
\end{minipage}
\caption{A typing rule for the value true in natural semantic syntax on the left and its equivalent ASCII representation on the right}
\label{trexampletrue}
\end{figure}
\begin{figure}[h]
\centering
\begin{minipage}{.45\textwidth}
  \centering
  \begin{equation}
    \tag{T-If}
    \frac{
      t_1 : \text{Bool}\quad
      t_2 : \text{T}\quad
      t_3 : \text{T}
    }{
      \text{if } t_1 \text{ then } t_2 \text{ else } t_3 : \text{T}
    }
  \end{equation}
  %\caption*{Pierce syntax}
  %\label{fig:sub1}
\end{minipage}%
\hspace{.1\textwidth}\begin{minipage}{.45\textwidth}
  \centering
\begin{lstlisting}[]
[T-If]
t1 : Bool,
t2 : t,
t3 : t
-----------------
If(t1, t2, t3): t
\end{lstlisting}
  %\caption*{ASCII representation}
  %\label{fig:sub2}
\end{minipage}
\caption{A typing rule describing an if-expression in natural semantic syntax and its equivalent ASCII representation}
\label{trexampleif}
\end{figure}

%- Figure of example natural deduction rules (from Pierce?) and ASCII representation
%No infix notation
%No environments

To express typing rules, we have defined an ASCII representation of the natural semantics syntax used by Pierce\cite{pierce}.
Our language can express a subset of the notation used by Pierce, with some differences and limitations.

Figures \ref{trexampletrue} and \ref{trexampleif} show two rules from Pierce in both their original syntax and our ASCII representation side by side.
The former figure describes a simple rule named T-True, which assigns the \verb|true| expression the type \verb|Bool|.

The largest difference can be seen in the expression to be typed, where Pierce uses the object language's native syntactic form, whereas our representation is based on the corresponding AST nodes.
In the first example, the difference is minor (\verb|true| and \verb|True| respectively) but the difference is more apparent in figure \ref{trexampleif}, where instead of the full syntactic form, the expression is written as an AST node with its children represented as parameters.
%Note the difference between the \verb|true| written in Pierce, representing the native syntactic form of the expression, and the \verb|True| in the ASCII representation, representing the name of the corresponding AST node.
%This difference is more apparent in figure \ref{trexampleif}, where instead of the full syntactic form, the expression is written as an AST node with its children represented as parameters.
This change is necessary to allow us to type arbitrary languages without needing to understand their syntax and grammar, though it does make translating rules from one syntax to the other less straightforward.

Another difference is the use of the metavariable \verb|T|, which has been switched to the lowercase \verb|t| in order to distinguish concrete types and type variables.
This change also aligns the syntax for type terms with the regular terms, where concrete nodes (such as \verb|If|) are written uppercase and variables (\verb|t1|, \verb|t2|, \verb|t3|) in lowercase.
Commas are also used to separate the premises, and the horizontal line separating premises from the conclusion is represented as a series of dashes.

Numerical values have not been implemented, but natural numbers can be expressed using Peano numbers\cite{peano}, utilising a zero value and successor function which represents the number incremented by one.
If a language has the syntax \verb|0 + 1| it may instead be represented as \verb|Add(Zero, Succ(Zero))|.


\subsubsection{Parser}\label{typingrulesparser}
The parser for typing rules is written using JFlex\cite{jflex}, a scanner generator, and Beaver\cite{beaver}, an LALR parser generator.
JFlex takes a series of regular expressions to generate a tokenizer for the parsed language.
The tokens are passed on to Beaver along with a parser definition in extended Backus-Naur form (EBNF), to generate a parser.


\subsubsection{Abstract syntax tree}\label{typingrulesast}
\begin{figure}[h]
\begin{lstlisting}[]
RuleSet ::= Rule*;

Rule ::= <Name> Conclusion:Formula Premises:Formula*;

abstract Formula;
HasType : Formula ::= Expr:Term Ty:TyTerm;

abstract Term;
Function : Term ::= <ID> Term*;
Value    : Term ::= <ID>;

abstract TyTerm;
TyVal : TyTerm ::= <ID>;
TyVar : TyTerm ::= <ID>;
\end{lstlisting}
  \caption{Typing rules abstract syntax tree specification}
  \label{trastspec}
\end{figure}

The abstract syntax tree for the typing rules language consists of a \lstinline{RuleSet} root node.
The root node contains only a list of rules, where each rule has a name, a conclusion and a list of premises.
The rule's name is currently unused but is intended to be utilised in error reporting, to clearly specify what rules are available for each node, or which rule is causing an error.

Both conclusion and premises are represented by the abstract HasType node, consisting of a term, which may be a function or value; and a typeterm, representing either a type value or a type variable.
For the conclusion, this node represents what type should be assigned to the term on the left, whereas for the premises, the node represents a requirement for the node on the left to have the type on the right.

\subsection{Template}
In addition to the compiled files, there are a number of files that are added to the output file that are identical for all generated type checkers, which we refer to as the template.
Some of these are key components of the type checker, but others are dummy components included solely for convenience of testing.
We expect that in a real world use case, our software would integrate into an object language's compiler pipeline, and utilise its own parser and project files to provide the abstract syntax tree for our type checking to tie into.
For testing purposes, we've written generic versions of these components, which work for any supported object language.
\subsubsection{Parser}\label{treebasedparser}
For testing purposes, our template comes with a generic tree-based parser.
Programs are written as a tree of AST node names followed by potential parenthesis within which a comma separated list of child nodes are written.
It recursively parses the tree, using Java's reflection API to find a class with a matching name, and a constructor with parameters of the same amount and types.
Figure \ref{boolinputexample} shows an example input file for the Bools language, which will be discussed further in section \ref{boolsast}.

\begin{figure}[h]
\begin{lstlisting}[]
Expression(
  Or(
    True,
    Or(
      True,
      False
    )
  )
)
\end{lstlisting}
  \caption{Example tree-representation input for the Bools language}
  \label{boolinputexample}
\end{figure}

This approach does have the issue of occasionally parsing invalid programs, due to the reflection API finding an additional parameterless default constructor.
This leads the parser to always accept nodes written with no children, such as \lstinline{Expression(Or())}, even if the AST specification requires them.
These children will be null, causing issues further down the line, though as this parser is only intended for testing it is of little concern.

\subsubsection{Project files}\label{projectfiles}
For ease of use the compiler will output a complete runnable Gradle project.
It can parse simplified tree-representations of programs, and utilise these to perform the type checking.

\subsubsection{Type checking aspect}\label{typecheckingaspect}
The type checking aspect contains the declaration of the \lstinline{type()} attribute for all AST nodes, as well as a default implementation.
This default implementation immediately produces a type error, to cause an error when the type of an expression not defined in the typing rules is demanded.

It also contains the implementation of the type matching method, which can be seen in figure \ref{typematches}.
It's defined for all \lstinline{Type} nodes, and checks whether the type's class is equal to or a subclass of the parameter type.

\begin{figure}[h]
  \begin{lstlisting}[language=jrag]
syn boolean Type.matches(Type t) {
  return t.getClass().isAssignableFrom(getClass());
}
  \end{lstlisting}
  \caption{Definition of the type matching method}
  \label{typematches}
\end{figure}

%\subsubsection{Executable}

%\subsection{Typing rule compiler}\label{typingrulecompiler}

%\subsection{Output type checker}
%\subsubsection{Tree-representation}
%\subsubsection{Type checking algorithm}\label{typecheckingalgorithm}
%Generate code for each node and typing rule
%Simple algorithm
%Recursive


%\section{Method (remove this?)} % describe how you go about solving the problem you defined. Also how do you show/prove that your solution actually works, and how well does it work.



\section{Implementation}\label{typingrulecompiler} % if your work involved building an artefact/implementation, give the details here. Note, that this should not, as a rule, be a chronological description of your efforts, but a view of the result. There is a place for insights and lamentation later on in the report, in the Discussion section.

%\subsection{Type checker generation}
The type checker generation is based on a single-responsibility principle, where each node of the abstract syntax tree is responsible for generating the code it corresponds to.
Once typing rules have been parsed, we end up with an abstract syntax tree, in the form of figure \ref{trastspec}, where the \verb|RuleSet| is the root node.
From the root node, calls propagate down the tree to fill in increasingly specific sections of the code.

This section details the implementation of our type checker generator, on a feature by feature basis.


%\subsubsection{Aspect generation}
\subsection{Aspect generation}
The \verb|RuleSet| node is responsible for generating the overall structure of the output file, a JastAdd aspect called \verb|TypingRules|.
It sorts its \verb|Rule| children by which nodes they apply to, so that if multiple tying rules type the same node, they can be inserted into the same method implementation.

%\subsubsection{Method implementation overview}
\subsection{Method implementation overview}
The implementation of a typing rule can range from a single return statement to a system of declarations of variables, type variables and control flow.
These are explained in further detail in subsequent sections, but here follows a quick overview.

Firstly, the algorithm checks if the number of premises is zero, in which case it immediately generates the conclusion, consisting of a return statement.
If there are premises, it first generates code for the declarations of variables and type variables.
This is followed by an if-statement to test whether the premises hold true, containing a return statement.
Should the premises not hold, a type error is produced.

%\subsubsection{Parameters}
\subsection{Parameters}
When the typing rules concern a node with parameters, these can be named arbitrarily, and a variable with the same name will be instantiated at the beginning of the method, fetching the corresponding child node by index.
These variables are then utilised in later premises or type variable declarations.

%\subsubsection{Premises/control flow}
\subsection{Premises/control flow}
The rule's premises are translated into an if-statement, which checks all types using a method \verb|matches| added to all Type nodes.

The current implementation of \verb|Type.matches(Type t)| checks that the Type it is called on is either of the same class or a subtype of the type \verb|t|.
This allows the language limited sub-typing at the type checker generation step, though the pros and cons of this haven't been evaluated.
It is also possible to override the \verb|matches| implementation for a specific Type, by adding a definition to a JastAdd aspect included in the output type checker.

%\subsubsection{Type variables}
\subsection{Type variables}
In the case of type variables, the generated code takes a dynamic approach to simplify the implementation.
Each type variable that appears in the conclusion is instantiated to a null value, and the code generated by each premise first checks if the value is still null and either assigns the variable its own type or tests to make sure the existing type matches its own.

%\subsubsection{Error handling}\label{errorhandling}
\subsection{Error handling}\label{errorhandling}
The current error handling consists of throwing a runtime exception at the first discovered type error, ceasing the type checking immediately.
This method was chosen solely for its simplicity of implementation, rather than its functionality.

It provides a stack trace allowing you to see where in the type checking code the error occurs (such as what typing rule fails), but doesn't currently provide any information about what section of the input program causes the error.
This tends to result in errors that are more useful for debugging the typing rule implementation, rather than providing useful information to the user of the type checker, where there is much room for improvements.

%Once typing rules have been parsed, we end up with an abstract syntax tree, in the form of figure \ref{trastspec}, where the \verb|RuleSet| is the root node.
%The \verb|RuleSet| node consists of a list of \verb|Rule| nodes, and begins by sorting each rule by which object language node it describes.
%
%The \verb|RuleSet| node then begins by generating the outline of a JastAdd aspect \verb|TypingRules|, and the definition for the method \verb|.type()| for each object language node.
%It then calls on the \verb|Rule| node to fill in the implementation of the method.
%
%A \verb|Rule| consists of a name, a conclusion, and a possibly empty list of premises that need to be true for the conclusion to be returned.
%In the simplest case of an empty list of premises, the entire content of the rule is generated by the conclusion.
%For rules containing premises, the code becomes more involved.
%Firstly, any variables or type variables used in the rule need to be declared, followed by a check to ensure each use of a type variable represents a node with the same type.
%Then it generates an if-statement corresponding to our premises, by letting each \verb|Premise| generate a boolean expression, all of which get joined by the AND operator.
%
%Both \verb|Premise|s and \verb|Conclusion|s are represented by the same abstract class \verb|Formula|, which currently contains a single implementation \verb|HasType|, consisting of an expression and a type.
%Depending on whether it is used as a premise or conclusion, it can either represent that the expression must have the specified type or that the expression should be given the specified type.

%\subsection{Type checker design}
%The provided typing rules compile into \verb|type()| methods, which return a value from the Type interface.
%For the most simple typing rules, this method's implementation will consist of a single return statement.
%
%Types are declared in an AST specification, currently provided by the template, allowing simple type hierarchies.


\chapter{Evaluation} % is the part where you present the finds. Depending on the area this part contains a subset or all of the following:
%\section{Experimental Setup} % should describe the details of the method used to evaluate your solution(s)/approach. Sometimes this is already addressed in the \textbf{Method}, sometimes this part replaces \textbf{Method}.
\section{Results} % contains the data (as tables, graphs) obtained via experiments  (benchmarking, polls, interviews). Here you should also describe the individual tables or graphs in text, pointing out interesting outliers and trends.
%\subsection{Input/output examples, with descriptions}
\subsection{Bools}

\begin{figure}[h]
\begin{lstlisting}[]
Expression ::= Term;

abstract Term;
True  : Term;
False : Term;
Or    : Term ::= Left:Term Right:Term;
Zero  : Term;
\end{lstlisting}
  \caption{AST specification for the Bools language}
  \label{boolsast}
\end{figure}
\begin{figure}[h]
\begin{lstlisting}[]
[T-True]
True : Bool

[T-False]
False : Bool

[T-Or]
left : Bool,
right : Bool
----------------------
Or(left, right) : Bool

[T-Zero]
Zero : Int
\end{lstlisting}
  \caption{Typing rules for the Bools language}
  \label{boolstr}
\end{figure}

\begin{figure}[h]
\begin{lstlisting}[language=jrag]
aspect TypingRules {

  syn Type Zero.type() {
    return new Int();
  }

  syn Type Or.type() {
    ASTNode left = getChild(0);
    ASTNode right = getChild(1);

    if(left.type().matches(new Bool()) &&
       right.type().matches(new Bool())) {
      return new Bool();
    }
    throw new RuntimeException("Typechecking failed");
  }

  syn Type True.type() {
    return new Bool();
  }

  syn Type False.type() {
    return new Bool();
  }
}
\end{lstlisting}
  \caption{Generated typing rules for the Bools language (reformatted for readability)}
  \label{boolstrgen}
\end{figure}
A simple example of a language is provided in figure \ref{boolsast}, consisting of three values, \verb|True|, \verb|False| and \verb|Zero|; and the boolean operator \verb|Or| with two parameters, Left and Right.
In the AST specification, there are no limitations on what terms can be provided as parameters to the \verb|Or| operator, allowing illogical constructs such as \verb|Or(True, Zero)|.

To prevent cases like these, we define typing rules via the specification in figure \ref{boolstr}.
The typing rules for \verb|True|, \verb|False| and \verb|Zero| contain no premises and define the type as \verb|Bool| and \verb|Int| as appropriate.
The typing rule for the \verb|Or| operator, which takes two parameters \verb|left| and \verb|right|, contains two premises, specifying that the \verb|Or| operator has the type \verb|Bool| only if both the \verb|left| and \verb|right| terms also have the type \verb|Bool|.

The typing rules from figure \ref{boolstr} generate the type definitions in \ref{boolstrgen}.
The simple rule definitions for the values compile into equally simple implementations, consisting of a single return statement of a newly constructed \verb|Type| object.
For the \verb|Or| node, the code becomes slightly more complex.
First two variables are defined, corresponding to the parameters in the typing rule, and assigned to the children with the index corresponding to the position among the parameters.
This is followed by an if-statement, recursively evaluating the children's types and comparing the result the type demanded in the premise.
If the condition is true, a \verb|Bool| type is returned.
If not, a runtime exception is thrown to convey a type error.

\subsection{If-else extension}

\begin{figure}[h]
\begin{lstlisting}[]
IfElse : Term ::= Cond:Term Then:Term Else:Term;
\end{lstlisting}
  \caption{Extension for the Bools AST in figure \ref{boolsast}}
  \label{ifelseast}
\end{figure}

\begin{figure}[h]
\begin{lstlisting}[]
[T-IfElse]
x: Bool,
y: a,
z: a
------------------
IfElse(x, y, z): a
\end{lstlisting}
  \caption{Extension for the Bools typing rules in figure \ref{boolstr} with an if-else term}
  \label{ifelsetr}
\end{figure}
\begin{figure}[h]
\begin{lstlisting}[language=jrag]
syn Type IfElse.type() {
  ASTNode x = getChild(0);
  ASTNode y = getChild(1);
  ASTNode z = getChild(2);

  Type tyvar_a = null;
  if(tyvar_a == null)
    tyvar_a = y.type();
  else if (!tyvar_a.matches(y.type()))
    throw new RuntimeException("Typechecking failed: Type variable mismatch");
  if(tyvar_a == null)
    tyvar_a = z.type();
  else if (!tyvar_a.matches(z.type()))
    throw new RuntimeException("Typechecking failed: Type variable mismatch");
  if(x.type().matches(new Bool()) &&
     y.type().matches(tyvar_a) &&
     z.type().matches(tyvar_a)) {
    return tyvar_a;
  }
  throw new RuntimeException("Typechecking failed");
}
\end{lstlisting}
  \caption{Generated typing rules for the if-else term, extending figure \ref{boolstrgen} (reformatted for readability)}
  \label{ifelsetrgen}
\end{figure}

%\begin{figure}
%\centering
%  \begin{minipage}[b]{.4\textwidth}
%  \centering
%\begin{lstlisting}[]
%[T-IfElse]
%x: Bool,
%y: a,
%z: a
%---------
%IfElse(x, y, z): a
%\end{lstlisting}
%  \captionof{figure}{A figure}
%  \label{fig:test1}
%\end{minipage}%
%\begin{minipage}[b]{.6\textwidth}
%  \centering
%\begin{lstlisting}[]
%syn Type IfElse.type() {
%ASTNode x = getChild(0);
%ASTNode y = getChild(1);
%ASTNode z = getChild(2);
%
%Type tyvar_a = null;
%if(tyvar_a == null) tyvar_a = y.type();
%else if (!tyvar_a.matches(y.type()))
%throw new RuntimeException("Typechecking failed: Type variable mismatch");
%if(tyvar_a == null) tyvar_a = z.type();
%else if (!tyvar_a.matches(z.type()))
%throw new RuntimeException("Typechecking failed: Type variable mismatch");
%if(x.type().matches(new Bool()) && y.type().matches(tyvar_a) && z.type().matches(tyvar_a)) {
%return tyvar_a;
%}
%throw new RuntimeException("Typechecking failed");
%}
%\end{lstlisting}
%  \captionof{figure}{Another figure}
%  \label{fig:test2}
%\end{minipage}
%\end{figure}
As an example of rules utilising type variables, we can extend the Bools language with an if-else term.
As shown in the AST extension in figure \ref{ifelseast}, it consists of three terms: a conditional, a term to be evaluated if the condition is true and a condition to evaluate if false.
A typing rule of this if-else term can be seen in figure \ref{ifelsetr}.
The rule has three premises, the first of which declares the conditional must have the type \verb|Bool|.
The next two declare that the two other children must be of the type \verb|a|, with the lowercase indicating a type variable.
This type variable \verb|a| also subsequently appears in the resulting type of the if-else term.

The code for this rule is shown in figure \ref{ifelsetrgen}, and begins with three parameter declarations as in previous rules, followed by a new type variable declaration on line 6, which is instantiated to null.
For each invocation of the type variable, a code section is generated, which checks if the type variable is still null, and if so assigns it to the type of the left-hand side term, or if it has been assigned checks whether the types match each other. Should any non-matches be found, a type error is thrown.

The rest of the method is similar, with premises being checked -- including a redundant check of the type variables -- before returning the type variable, or a type error being thrown.

\section{Research questions}
\subsection{\rqone}
Our project has shown that generating type checkers using RAGs is a viable solution for a number of different language constructs.
%To assess our implementation, we'll go through the examples used by Pierce\cite{Pierce} to see which cases we can successfully express.
To evaluate the completeness of our implementation, we refer to Pierce\cite{Pierce} as a reference work.
The typing rules are introduced in chapter 8, starting with the simple examples shown in section \ref{sectionlanguage}.
We've implemented support for simple type declarations, where a value or function always has a certain type.
These simple rules aren't of much interest in themselves but are an important backbone to the subsequent analysis.
We also support type declarations with premises that must hold for the rule to apply, allowing us to express relationships between types and bringing with them the possibility of type errors.

Type variables extend these relationships further by providing a layer of abstraction, allowing us to write rules where the types aren't precisely defined.
This enables rules where the return type of an expression depends on its child expressions, or where child expressions must have the same types.

A major feature missing from our implementation is the concept of type environments or typing contexts, providing a mapping from variables and functions to types.
This prevents us from generating type checkers for even simple general purpose languages.

\subsection{\rqtwo}
We have approached parsing typing rules into a JastAdd attribute \verb|type()|, which either returns a \verb|Type| value, or throws a runtime exception if the expression is invalidly typed.

We've chosen to represent the right-hand side of type equations, the types themselves, as an abstract AST class.
While our current implementation only supports simple types, this representation gives us a lot of flexibility for future extensions.
Parametric types, such as lists where the type of the list contains information about the types of its elements, could be expressed as simply as \lstinline{MyList : Type ::= Type;}.
The current implementation of \lstinline[language=java]{matches()} would however consider all lists to match, without comparing the child nodes.
Perhaps the default implementation could be extended to compare all child elements, or these more advanced types would require manually overriding the method.

We've implemented premises as conditions of a single if-statement, where we check that each premise holds true before returning the type, or falling through to a type error if the premises don't hold.
It might instead be worthwhile to check each condition individually, to be able to specify in the error message precisely which premises have failed and why.
%This would perhaps make it easier to implement informative type errors, as you could report precisely which premise is failing.
If paired with the current error handling of throwing an exception to convey type errors, it would make it harder to implement having multiple valid rules providing the type of an expression, as the first failure would seize the evaluation of the type.
An alternative error handling would suit it better, one able to collect multiple errors without seizing evaluation, perhaps merely adding all the errors to a list and checking whether it is empty before returning a type.

The variables in the typing rules are compiled into regular Java variables containing the AST node.
Notably, the declarations of these variables type them merely as \verb|ASTNode|.
As we currently only utilise the \lstinline{type()} attribute, which is declared for all nodes, this lost information has little impact.
However, in the future it may become relevant to type these more specifically, to support more complex rules that require deeper analysis within the tree.

Type variables similarly are implemented as Java variables, though they are initiated as null, to represent the type variable's unassigned state.
This is followed by a check for each point of use in the typing rule, to see whether the type variable is still unassigned and if so assign it.
This approach leaves much room for improvement and optimisation, by finding the first use of each type variable during the rule compilation, and generating a single declaration statement initialising it to the type of the corresponding expression.

A cleaner solution to this might be view rules as a kind of pattern matching, where each rule is evaluated one by one until a matching one is found.
Instead of reporting the reason any individual rule failed, the error might instead display all the rules it tried to apply, perhaps with a list of non-holding premises for each one.

\subsection{\rqthree}
%Splitting code between multiple JastAdd components (and java) can get messy
Writing idiomatic JastAdd components often requires splitting your code into many different places.
We attempted to keep each node in the tree responsible for generating the code it corresponds to, which avoids parent nodes having to check their children's structure with \verb|isInstanceOf|, but also means even generating a simple rule can require a dozen calls between different nodes.
There's a tradeoff to be made between the single responsibility of each component making it easy to verify its correctness, but the complicated interdependence making it hard to grasp the full picture.

Using JastAdd simultaneously as a library and a build component

%Having to use a hacky method to access private JastAdd methods to parse a second AST at runtime. (Beyond jastadd's scope?)
Some of the features we intended to support, such as verifying that typing rules correspond to valid nodes within the object language AST, were complicated by having to parse the object language AST at runtime, using JastAdd as a library rather than a build tool.
JastAdd does not expose any methods for parsing an AST tree at runtime, and we had to access undocumented, private methods through Java's reflection API to get the relevant information.
Unfortunately, the resulting data was hard to work with, and we could not allocate enough time to implement the planned features.
It may be that this use case is beyond the intended scope of JastAdd, or it is perhaps only poorly documented.
In either case, while our experimentation has shown it to be technically possible, the complexity is worth bearing in mind for future work.

Not being able to perform these error checks at runtime means our translation will emit nonfunctional typing definitions if a mistake is written in the typing rules.
These errors will then go unreported until the output project is compiled or run, at which point the user will have to attempt to trace these errors back to the typing rule definition, to find the actual cause.


\chapter{Discussion} % allows for a longer discussion and interpretation of the results from the evaluation, including extrapolations and/or expected impact. Focus here on a broader view of the results, talking about the relation between the different finds.\footnote{Bad practice is to display graphs in Results and then describe them textually one by one in here. No! Both sections should have some discussion, but one targets individual finds and the other tries to bridge between these adopting a more overarching viewpoint.} This might also be a good place to describe your positive and negative experiences related to the work you carried out.
% Occasionally these sections are intermingled, if this allows for a better presentation of your work. However, try to distinguish between measurements or hard data (results) and extrapolations, interpretations, or speculations (discussion).
%\section{Supported features}
%\section{Development learnings}
\chapter{Conclusions} % should summarize your findings and possible improvements or recommendations.
Our experiments have shown that reference attribute grammars are a flexible method for implementing type checker generators.
Implementing the first top-to-bottom functioning product was challenging and took quite a lot of work, but extending it with additional features such as type variables turned out to be a surprisingly painless experience.

However, our compiler still has a long way to go before it can be used for real world use cases and general purpose languages.
Chief among the missing features is the concept of environments, without which we're unable to support even common language features such as variables or functions.

%\section{Summary of findings}
\section{Future work}
\subsection{Environments}
Implementing environments, or type contexts, would be the clear next step for this project.
However, its implementation is not entirely clear-cut, with several aspects requiring consideration.

The essence of environments is the mapping of variables or functions to types, and an appropriate representation of this would need to be found.
A method often used by traditional type checkers is a symbol table, a separate data structure mapping language constructs to their types.
In our case, we may instead be able to leverage our reference attribute grammars to store the information within the AST.
By connecting each use of a variable or function to the AST node representing its declaration site, we could utilise the node to store the type information.
This approach would however also have to consider the typing of external language constructs, such as built-in functions or those imported from external libraries, for which we wouldn't have access to the declaration site.

%An additional concern is that of scoping, which different languages may have different rules for.

A type checker working on these principles is certainly a possibility, though it remains to be seen how it could be generalised to the generation of typing rules for arbitrary languages.

\subsection{Improved error handling}
The current exception-based error handling is rather primitive and leaves much to be desired.
Some improvements, such as provide more useful error messages, could be possible by making minor changes to how these exceptions are generated.
Information such as what part of the input program the type error occurred at, what the failing typing rule was and what prerequisites it has, could be added to the exception message, for a quick usability improvement.

An improvement demanding more extensive changes would be collecting multiple errors, instead of seizing the type checker at the first discovered error.
This could be implemented by adding another type class to be returned when an error occurs, representing the "Any" type.
Any \verb|matches()| call on this type would return true, to avoid one error cascading into many, but still allowing other unrelated errors to be discovered.
This implementation would also need new functionality to collect the error messages, perhaps by splitting the type resolution and type errors into separate attributes for each node, where the type errors propagate to a program-wide collection.


\subsection{Verify rules against AST}
Major improvements to the user experience could be made by tying the typing rules to the object language AST before generating the type checker.
Currently, there are no checks in place to verify the completeness of the typing rules.
If a user accidentally leaves out the typing rule for a certain construct, they'll receive no warning until the outputted type checker attempts to check the expression's type.

Similarly, no checks are made to ensure the nodes described in the typing rules actually exist within the language's AST.
Our project will compile invalid or misspelled typing rules without complaint, leading to errors which won't be caught until the outputted type checker is attempted to be compiled.

\subsection{Handle multiple rules for the same node}
In type systems it is generally considered valid to have multiple typing rules for the same construct, with different, non-intersecting prerequisites.
It could for example be useful to type an addition operator for a variety of different numerical types, which may not have a common ancestor.

Most of the work to support this is in place, though the first rule to fail would throw a type error exception, preventing the later rules from evaluating.
These errors would either have to be caught, and only emitted if all rules had failed, or a new error handling system not based around exceptions could be introduced.
Additionally, an extra layer of scoping would have to be introduced, to prevent variable naming collisions between the different rules.
This could be solved simply by wrapping each rule within brackets, creating a separate scope for the evaluation of each rule.

%add(int, int): int, add(double, double): double)
\subsection{Better support for numbers, strings, etc.}

\subsection{Improved type checking algorithm}


% Should use consistent formatting when it comes to Names ("FirstName LastName", or "F. LastName")
%\printbibliography
\makebibliography{MSc} % is a must in a scientific report. {\LaTeX} and \texttt{bibtex} offer great support for  handling references and automatically generating bibliographies.

\begin{appendices} %should contain lengthy details of the experimental setup, mathematical proofs, code download information, and shorter code snippets. Avoid longer code listings. Source code should rather be made available for download on a website or on-line repository of your choosing.
\chapter{Source code}
\url{https://github.com/nichobi/thesis-project}

% display used packages information unless noflielist is used in the cslthse-msc package option
\printfilelist

%make sure we're on even page with the pop-sci
\checkoddpage
\ifoddpage
\else
  \newpage
  \thispagestyle{empty}
  \mbox{ }
\fi
\includepdf[pages={1}]{popsci/popsci.pdf}
\end{appendices}

\end{document}
